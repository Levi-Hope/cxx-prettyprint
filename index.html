<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<html>
  <head>
    <title>A C++ Container Pretty-Printer</title>
    <link type="text/css" rel="stylesheet" href="default.css">
    <meta http-equiv="Content-type" content="text/html; charset=iso-8859-1">
    <style type="text/css">
      html { margin: 0; padding: 0; font-size: medium; font-family: Calibri, "DejaVu Sans", "Trebuchet MS", Helvetica, sans-serif; }
      body { margin: 3em auto; max-width: 66em; padding: 0; line-height: 1.5em; }
      h2 { font-size: 1.25em; font-weight: bold; line-height: 1.25em; margin: 1em 0 .5em 0; padding: 0; }
      h1 { font-size: 2em; font-weight: bold; line-height: 1.25em; }
      a:link, a:visited { color: maroon; text-decoration: none; border-bottom: 1px dotted #DAA; }
      a:link:hover, a:visited:hover { color: white; border: none; background-color: maroon; }
      code { font-family: Consolas, "DejaVu Mono Sans", Courier, monospace; }
      p.footnote { font-size: .8em; line-height: 1em; }
      span.subtitle { font-size: .75em; font-weight: normal; font-style: italic; }
      div.listing { font-family: monospace; padding: 0 2em; white-space: pre; }
    </style>
  </head>
  <body>

    <h1>cxx-prettyprint: A C++ Container Pretty-Printer</h1>

    <p>Please visit the <a href="https://github.com/louisdx/cxx-prettyprint">source code repository</a> on GitHub.</p>

    <p><strong>Download:</strong> <a href="http://github.com/louisdx/cxx-prettyprint/zipball/master">zip ball</a>,
    <a href="http://github.com/louisdx/cxx-prettyprint/tarball/master">tar.gz ball</a>.</p>

    <p><strong style="margin-right: 1em;">Check out:</strong> <code>git clone git://github.com/louisdx/cxx-prettyprint</code> (see below)</p>

    <h2>Quick start</h2>

    <p>Download <a href="https://raw.github.com/louisdx/cxx-prettyprint/master/prettyprint.hpp">prettyprint.hpp</a>
    and place it in your source directory. Add <code>#include "prettyprint.hpp"</code> to your source file. You are ready!</p>

    <div class="listing">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include "prettyprint.hpp"

int main()
{
  std::vector&lt;int&gt; foo;
  foo.push_back(1);
  foo.push_back(2);
  foo.push_back(3);

  std::cout &lt;&lt; "My vector: " &lt;&lt; foo &lt;&lt; std::endl;
}</div>

    <h2>Description</h2>

    <p><em>cxx-prettyprint</em> is a header-only library for C++ which provides printing via the &lt;&lt;-operator
    for any container class. Before we go into the details, let us quickly think about what we need to do:</p>

    <ul>
      <li>An empty container should print as <code>[]</code>.</li>
      <li>A container with a single element should print as <code>[3]</code>.</li>
      <li>A container with <var>n</var>&nbsp;&gt;&nbsp;1 elements should print as <code>[3, -11, 137]</code>;
      note that there are <var>n</var>&nbsp;&minus;&nbsp;1 delimiters.</li>
      <li>Each element should be printed with its own output operator, in particular nested containers should
      be printed by recursively applying the above rules.</li>
    </ul>

    <p>The <em>cxx-prettyprint</em> library provides precisely this functionality. We are using the following default
    settings for the delimiters (but see below for how to customize):</p>

    <ul>
      <li>The separating delimter is always &ldquo;<code>, </code>&rdquo; (comma, space).</li>
      <li>Pairs and tuples are enclosed in round brackets (parentheses): <code>(1, foo)</code>.</li>
      <li>Sets are enclosed in curly braces: <code>{1, 5, 11}</code>.</li>
      <li>All other containers are enclosed in square brackets: <code>[1.4, -1.2, Inf, 88.6]</code>.</li>
    </ul>
    <p>These lexical conventions attempt to mimick popular mathematical notation for tuples, sets and vectors, respectively.</p>

    <h3>Example</h3>
    <p>Suppose we map integers to sets of strings.</p>
    <div class="listing">typedef std::map&lt;int, std::set&lt;std::string&gt;&gt;; map_type;

map_type foo = { { 1, std::set&lt;std::string&gt;{ std::string("cat"),  std::string("dog"),  std::string("doe") } },
                 { 3, std::set&lt;std::string&gt;{ std::string("goose"), std::string("moose"), std::string("ruse") } } };

std::cout << foo << std::endl;</div>
    <p>The output would look like so:</p>
    <div class="listing">[(1, {cat, doe, dog}), (3, {goose, moose, ruse})]</div>

    <h2>Advanced usage: Customizing the delimiters</h2>

    <p>The delimiters that are used by the output operation are deduced from compile-time static class constants.
    In particular, if <code>T</code> denotes any container type, then the appropriate delimiters are defined
    by the following templated structure:</p>
    <div class="listing">namespace pretty_print
{
    template&lt;typename TChar&gt; struct delimiters_values
    {
        typedef TChar char_type;
        const TChar * prefix;
        const TChar * delimiter;
        const TChar * postfix;
    };

    template&lt;typename T, typename TChar&gt; struct delimiters
    {
        typedef delimiters_values&lt;TChar&gt; type;
        static const type values; 
    };
} // namespace</div>

    <p>The templates are parametrized on <code>TChar</code>, the type of the character,
    which is <code>char</code> for <code>std::cout</code> and <code>wchar_t</code> for
    <code>std::wcout</code>. You must define <code>delimiters&lt;T, TChar&gt;::values</code>
    for your container type <code>T</code>. For example, the default delimiters for
    <code>TChar = char</code> are declared  as follows:</p>

    <div class="listing">template&lt;typename T&gt; struct delimiters&lt;T, char&gt; { static const delimiters_values&lt;char&gt; values; };
template&lt;typename T&gt; const delimiters_values&lt;char&gt; delimiters&lt;T, char&gt;::values = { "[", ", ", "]" };</div>

    <h3>Overriding delimiters</h3>

    <p>The most straight-forward way to override delimiters for a particular container is to specialize the <code>delimiters</code> struct
    accordingly. For example, if we want special delimiters for a vector of doubles, we specialize as follows:</p>

    <div class="listing">template&lt;&gt; const pretty_print::delimiters_values&lt;char&gt; pretty_print::delimiters&lt;std::vector&lt;double&gt;, char&gt;::values = { "< ", " ; ", " >" };</div>

    <p>An alternative solution is to provide your own delimiters class. That is a class with a public, static constant named <code>values</code>
    and of type <code>pretty_print::delimiters_values&lt;TChar&gt;</code>, where you must provide a concrete instance of <code>TChar</code> suitable
    for your output operation (usually <code>char</code>). With such a class, say <code>MyDelims</code>, you can invoke a wrapper class for any
    container, say <code>v</code>:</p>

    <div class="listing">std::cout &lt;&lt; pretty_print::custom_delims&lt;MyDelims&gt;(v) &lt;&lt; std::endl;</div>

    <p>(The wrapper class <code>custom_delims</code> uses type erasure to call the relevant internal helper instance
    of the type of <code>v</code>.) Your delimiter class could for example be declared as follows:</p>

    <div class="listing">struct MyDelims { static const pretty_print::delimiters_values&lt;char&gt; values; };
const pretty_print::delimiters_values&lt;char> MyDelims::values = { "&lt;", "; ", "&gt;" };</div>

    <p>As a rule of thumb: Specialize <code>pretty_print::delimiters</code> if you want uniform delimiters for
    a particular container type, and use the <code>pretty_print::custom_delims</code> wrapper with your own
    delimiter class if you want to use a fixed set of delimiters for a variety of containers on a one-off basis.</p>


    <p>If you like to help out, just send me a message on <a href="https://github.com/louisdx/cxx-prettyprint">GitHub</a>,
    <a href="mailto:yoursecretsaresafe@googlemail.com">email me patches or suggestions</a>, or send pull requests.</p>

    <p style="text-align: right; font-style: italic;">louisdx</p>

  </body>
</html>
